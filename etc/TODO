[ This is -*-Indented-Text-*- ]

TODO list for Jade
******************

Bugs are marked !, things that should be done soon are marked +,
and more long-term ideas are marked -

Last modified: January 13, 1999


Outstanding bugs
================

 ! Putting a breakpoint in a .jaderc file doesn't work correctly; the
   debugger is entered, but the commands don't work

 ! Reverse isearch doesn't update its position if a longer match
   appears as a result of more characters being added to the regexp

 ! C mode still mis-indents some straightforward statements

 ! mail-parse-address doesn't always work. It should really take the
   _list_ of atoms generated by mail-parse-group as its input and scan
   that. (Example of broken address: `Foo "" Bar <foo@bar.com>')

 ! non-local file handles aren't finalised correctly when they're
   garbage collected, they're simply deallocated without calling
   close-file on them (this could be construed a ``feature'' rather
   than a bug?)

 ! changing glyph-tables via extents only half works---the
   make_window_glyphs function reloads the glyph table from each newly
   entered extent, but the uncached_string_glyph_length and char_col
   functions don't. Fixing this might mean changing the extent cache
   architecture

 ! {x,y}-scroll-step-ratio should be made into normal variables

 ! It's relatively easy to blow the stack when regexp matching. Try
   searching for `/\*(.|\n)*\*/' in a C file with reasonable large
   comments.

 ! If a compiled file FOO.jlc is made from source file FOO, but FOO is
   newer, load doesn't notice, and loads the invalid FOO.jlc


General programming tasks:
==========================

 + Add mouse-face and mouse-keymap extent properties

 + Allow redisplay to be preempted by input becoming available (test
   where in the redisplay algorithms though, in the diff, or the
   drawing, or both!?)

   [ I tried this, using SIGIO, to preempt the make_window_glyphs
     function since the profiler suggested that it's this function
     that takes the most time. The problem was that dragging the mouse
     saturated the input channel, and therefore nothing ever got
     drawn. I need to think this through some more. ]

 + Test defsubst declared functions when dumped

 + Write a buffer compaction function (improve the locality of
   reference of lines in a buffer)

 + Clean up the mail-dir interface. Maybe turn it into a fully-fledged
   address book (not very hard, just easier access to non-standard
   fields)

   Also store things like message id of last message sent/received to
   this person (all message id's ever sent/received?), what else..?

 + Make swap-del-bs a runtime option, not compile time (or just get rid
   of it altogether?)

 - Mail reader extensions

   Allow sorting by more than one predicate. i.e. ``if scores are
   equal, compare by date'' kind of thing

   Should re-run the after-parse rules when the message properties
   change. E.g. if the rule sets the summary-face depending on whether
   the message is unread or not, when the message becomes read we want
   the face to return to normal

 - Syntax highlighting

   I don't like this myself, but it seems to be popular

 - Demand load buffer contents

   If a buffer is unmodified, and hasn't been used for <some arbitrary
   time>, there's no reason to keep its contents in memory. The buffer
   isn't thrown out, just its contents. If at some point in the future
   the contents need to be accessed, they can be reloaded (with all
   other state preserved)

   Of course, this is just a coarse-grained virtual memory thing. It
   could be quite helpful though, with little impact on the user

 - Extend the online help

   `C-h m' is the general `context sensitive' help binding. This should
   work in more circumstances, e.g. in prompts

   Allow `links' between help messages

 - Allow jadeclient to communicate inter-host.

   What security mechanisms should I use? Xauth is one obvious
   solution, use XauGetAuthByAddr() to get the cookie, then send it
   down the link. Of course, this is no use if the client isn't running
   on an X display; then we could resort to what? Scan the .rhosts
   file? Generate our own magic cookie at server startup? Just allow
   certain hosts and deny others?...

 - In the Lisp VM replace the `bindstack' list with a vector. Means
   that the compiler will need to track the binding depth as well as
   the stack depth.

 - Use two passes for `concat'; the first pass calculates the new
   string's length, the second builds it

 - Asynchronous notification of when a file changes externally

 - Change RCS mode to do generic version control, with backends for
   various systems (RCS, SCCS, ...)

   Note that CVS has its own mode since it's conceptually different; it
   deals with groups of files, whereas RCS only worries about files in
   the singular. But then again, there's no reason why individual files
   can't be accessed through the generic vc

 - Add more backends for accessing remote files

   Make remote-rcp work properly, and add others (ssh, http, ..?)

 - Implement an HTML-view mode that renders HTML in one buffer into
   another buffer for viewing

 - Make the compiler optimise its output

 - Write a LISP module to interface with the PalmPilot (use the
   pilot-link tools to do the messy stuff)

 - Abstract the Lisp extension language into a separate package. Have
   hooks for adding new types, and whatever else is needed. This will
   be quite a big task, since a lot of the code is quite tangled

 - Make the LISP lexically scoped


X11 tasks:
==========

 - Scroll bars, menus. Would it be possible to enable use of GTK at
   compile time? Is it possible to handle multiple displays? I don't
   think so, but that's not a huge loss..

   What would be truly great would be to code a gtk jade_frame widget
   that is basically what we have at the moment--the grid of characters
   with paned views, then write a gtk Lisp binding. This would give
   total control

 - `Fuzzy' colour allocation; if a colour can't be allocated find the
   nearest match 


Unix tasks:
===========

 + Use /dev/ptmx to open pseudo-terminals (configuration option), I
   quote from a linux-kernel message:

	"...Opening /dev/ptmx opens the first available master pty; in
	Unix98 conventions, you would then call ptsname() on the open
	file descriptor to get the name of the associated slave pty..."

   And from the Solaris "STREAMS Programming Guide":

	"int fdm fds;
	char *slavename;
	extern char *ptsname();

	fdm = open("/dev/ptmx", O_RDWR);	/* open master */
	grantpt(fdm);				/* change perm. of slave */
	unlockpt(fdm);				/* unlock slave */
	slavename = ptsname(fdm);		/* get name of slave */
	fds = open(slavename, O_RDWR);		/* open slave */
	ioctl(fds, I_PUSH, "ptem");		/* push ptem */
	ioctl(fds, I_PUSH, "ldterm");		/* push ldterm */"

   [ This has been done. I don't know about the generality of the
     I_PUSH stuff though... ]

   Can also send signals via the pty:

	"ioctl (fd, TIOCSIGNAL, SIGINT)"

   sends SIGINT to the slave.


Manual tasks:
=============

 + Update it for version 4. This is a big task.
