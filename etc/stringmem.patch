
These patches allow the stringmem allocation buckets to be defined more
flexibly. Both the size of each block, and the number of blocks per
allocation chunk to be defined arbitrarily, with added cost at
allocation time (linear search to match alloc sizes to buckets).

--- stringmem.h	Tue Feb  1 00:07:54 1994
+++ stringmem.h.old	Mon Jan 31 23:24:03 1994
@@ -45,10 +45,7 @@
     int		    mbu_FreeCount;
 } MEMBUCKET;
 
-#define GRAIN	      8
-#define MAXBUCKETSIZE 128
-#define NUMBUCKETS    (MAXBUCKETSIZE / GRAIN)
-#define MBLOCKSIZE    (2044 - sizeof(MEMBLOCK))
+#define NUMBUCKETS     23
 
 typedef struct STRMEM {
     MEMBUCKET	    sm_MemBuckets[NUMBUCKETS];
--- stringmem.c	Mon Jan 31 23:52:36 1994
+++ stringmem.c.old	Mon Jan 31 23:23:54 1994
@@ -16,6 +16,30 @@
 #include "jade.h"
 #include "jade_protos.h"
 
+/*
+ * This array controls how many MEMCHUNKs are allocated at once for each
+ * size of block.
+ */
+Prototype int DefChunksPerBlock[NUMBUCKETS];
+int DefChunksPerBlock[NUMBUCKETS] = {
+    128, 128, 64, 64, 32, 32, 24, 24, 24, 24, 16, 16, 16, 16, 8,
+    8, 8, 4, 4, 4, 2, 2, 2
+};
+/*
+ * This controls the number of bytes in each bucket
+ */
+Prototype int MemPerChunk[NUMBUCKETS];
+int MemPerChunk[NUMBUCKETS] = {
+    8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 104, 120, 152, 184, 248, 312,
+    440, 568, 696, 824, 952, 1024
+};
+
+/*
+ * Allocations over this size go through standard malloc(), this must
+ * correspond to the largest value in MemPerChunk.
+ */
+#define MAXBUCKETSIZE 1024
+
 int
 initstrmem(STRMEM *sm)
 {
@@ -23,7 +47,6 @@
     for(i = 0; i < NUMBUCKETS; i++)
     {
 	NewMList(&(sm->sm_MemBuckets[i].mbu_MemBlocks));
-	sm->sm_ChunksPerBlock[i] = MBLOCKSIZE / MCHNK_SIZE((i + 1) * GRAIN);
 #ifdef STRMEM_STATS
 	sm->sm_AllocCount[i] = sm->sm_FreeCount[i] = 0;
 #endif
@@ -61,7 +84,7 @@
 {
     MEMBLOCK *mbl;
     int numchunks = sm->sm_ChunksPerBlock[sizeIndex];
-    int chnkbytes = (sizeIndex + 1) * GRAIN;
+    int chnkbytes = MemPerChunk[sizeIndex];
     if(mbl = mymalloc(MBLK_SIZE(chnkbytes, numchunks)))
     {
 	MEMCHUNK *mc = mbl->mbl_Chunks;
@@ -86,7 +109,6 @@
 sm_alloc(STRMEM *sm, int size)
 {
     MEMCHUNK *mc;
-    assert(size > 0);
     if(size > MAXBUCKETSIZE)
     {
 	if(mc = mymalloc(MCHNK_SIZE(size)))
@@ -108,8 +130,14 @@
     else
     {
 	MEMBUCKET *mbu;
-	int bucket = (size - 1) / GRAIN;
+	int bucket;
+	/*
+	 * Find which bucket this allocation falls in
+	 */
+	for(bucket = 0; MemPerChunk[bucket] < size; bucket++)
+	    ;
 	mbu = &sm->sm_MemBuckets[bucket];
+
 	if(!(mc = mbu->mbu_FreeList))
 	{
 	    if(!newmemblock(sm, mbu, bucket))
@@ -124,6 +152,7 @@
 #endif
     }
     return(mc->mc_Mem.mem);
+/*  return((void *)(((int *)mc) + 1)); */
 }
 char *
 sm_strdupn(STRMEM *sm, const char *old, int len)
@@ -152,7 +181,7 @@
 {
     MEMBLOCK *mbl = (MEMBLOCK *)sm->sm_MemBuckets[bucketIndex].mbu_MemBlocks.mlh_Head;
     MEMBLOCK *nxt;
-    int chnksiz = MCHNK_SIZE((bucketIndex + 1) * GRAIN);
+    int chnksiz = MCHNK_SIZE(MemPerChunk[bucketIndex]);
     int numchnks = sm->sm_ChunksPerBlock[bucketIndex];
     while(nxt = (MEMBLOCK *)mbl->mbl_Node.mln_Succ)
     {
